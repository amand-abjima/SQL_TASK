--FUNCTIONS IN SQL SERVER.

--CREATE A FUNCTION WITHOUT PARAMETER.

--USER DEFINED SCALAR VALUE FUNCTION.

CREATE FUNCTION SHOWMESSAGE1()
RETURNS VARCHAR(100)
AS 
BEGIN
    RETURN 'HELLO WORLD!!'
END

SELECT DBO.SHOWMESSAGE1();

--CREATE A FUNCTION WITH SINGLE PARAMETER.

--SCALAR FUNCTION.

CREATE FUNCTION NUMSQUARE(@NUM AS INT)
RETURNS INT
AS
BEGIN
RETURN (@NUM * @NUM)
END

SELECT DBO.NUMSQUARE(4) AS SQUARES;

SELECT DBO.NUMSQUARE(5) AS SQUARES;

--CREATE A FUNCTION WITH MULTIPLE PARAMETERS.

--SCALAR FUNCTION.

CREATE FUNCTION ADDITIONS(@NUM1 AS INT,@NUM2 AS INT)   --THESE PARAMETERS ARE INPUT PARAMETERS.WE CAN'T USE OUTPUT PARAMETERS WITH FUNCTION.
RETURNS INT
AS
BEGIN
RETURN (@NUM1 + @NUM2)
END

SELECT DBO.ADDITIONS(3,6) AS ADDITION;

SELECT DBO.ADDITIONS(1967,3698) AS ADDITION;

SELECT DBO.ADDITIONS(345,-698) AS ADDITION;

--ALTER A FUNCTION.

ALTER FUNCTION NUMSQUARE(@NUM AS INT)
RETURNS INT
AS
BEGIN
RETURN (@NUM * @NUM * @NUM)
END

SELECT DBO.NUMSQUARE(8) AS CUBES;

SELECT DBO.NUMSQUARE(7) AS CUBES;

--DROP A FUNCTION.

DROP FUNCTION DBO.FUNCTION_NAME;

DROP FUNCTION DBO.SHOWMESSAGE1;

SELECT DBO.SHOWMESSAGE1(); --WHEN WE WILL DROP A FUNCTION THEN WE WILL NOT USE ROUND PARENTHESES ().

--SCALAR FUNCTIONS CAN USE LOGIC SUCH AS IF BLOCKS OR WHILE LOOPS.

CREATE FUNCTION CHECKNUMBER(@NUM AS INT)
RETURNS VARCHAR(50)
AS
BEGIN
DECLARE @STR VARCHAR(50)
IF @NUM %2 = 0
BEGIN
  SET @STR = 'NUMBER IS EVEN NUMBER'
END
ELSE
BEGIN
  SET @STR = 'NUMBER IS ODD NUMBER'
END
RETURN @STR
END

SELECT DBO.CHECKNUMBER(5) AS NUMBER;

SELECT DBO.CHECKNUMBER(18) AS NUMBER;

--SCALAR FUNCTION CAN CALL OTHER FUNCTIONS.

CREATE FUNCTION MYDATE()
RETURNS DATETIME
AS
BEGIN
RETURN GETDATE()
END

SELECT DBO.MYDATE();

/*CREATE FUNCTION MAXOFNUM(@SALARY AS INT)
RETURNS INT
AS
BEGIN
RETURN (SELECT MAX(@SALARY) FROM EMPLOYEE2)
END*/

--USER DEFINED INLINE TABLE VALUED FUNCTION.

--INLINE TABLE VALUED FUNCTION WITHOUT PARAMETER.

CREATE FUNCTION FN_GETCUSTOMER()
RETURNS TABLE
AS
RETURN (SELECT * FROM SALESLT.CUSTOMER)

SELECT * FROM FN_GETCUSTOMER();

SELECT * FROM DBO.FN_GETCUSTOMER();

SELECT * FROM SALESLT.PRODUCT;

--INLINE TABLE VALUED FUNCTION WITH PARAMETER.

CREATE FUNCTION FN_GETPRODUCT(@PRODUCTMODELID AS INT)
RETURNS TABLE
AS
RETURN (SELECT * FROM SALESLT.PRODUCT WHERE PRODUCTMODELID > @PRODUCTMODELID)

SELECT * FROM DBO.FN_GETPRODUCT(30);

--WE CAN ALSO USE INLINE TABLE VALUED FUNCTIONS WITH JOINS.

SELECT * FROM STUDENT;   /* IN INLINE TABLE VALUED FUNCTION WE RETURN TABLE BY USING SINGLE SELECT STATEMENT*/

SELECT * FROM STUDENT_MARKS;

CREATE FUNCTION FN_GETSTUDENT(@RNO AS INT)
RETURNS TABLE
AS
RETURN (SELECT * FROM STUDENT WHERE RNO >= @RNO)

SELECT * FROM DBO.FN_GETSTUDENT(5);

SELECT * FROM DBO.FN_GETSTUDENT(5) AS A
INNER JOIN STUDENT_MARKS AS B
ON A.RNO = B.ROLLNO;

--USER DEFINED MULTI STATEMENT TABLE VALUED FUNCTIONS.

/* IN MULTI STATEMENT TABLE VALUED FUNCTION WE RETURN TABLE BY USING MULTIPLE SELECT STATEMENT*/

SELECT * FROM EMPLOYEE;

ALTER TABLE EMPLOYEE ADD GENDER VARCHAR(30);

UPDATE EMPLOYEE SET GENDER = 'FEMALE' WHERE ID = 700;

CREATE FUNCTION FN_GETEMPGENDER(@GENDER AS VARCHAR(30))
RETURNS @MYTABLE TABLE(E_ID INT,E_NAMES VARCHAR(30),E_CITY VARCHAR(30),E_GENDER VARCHAR(30))
AS
BEGIN
INSERT INTO @MYTABLE
SELECT ID,NAMES,CITY,GENDER FROM EMPLOYEE WHERE GENDER = @GENDER
RETURN
END

SELECT * FROM DBO.FN_GETEMPGENDER('MALE');

SELECT * FROM DBO.FN_GETEMPGENDER('FEMALE');

--WE CAN ALSO PERFORM ABOVE QUERY BY USING INLINE TABLE VALUED FUNCTION.

CREATE FUNCTION FN_GETEMPGENDER1(@GENDER AS VARCHAR(30))
RETURNS TABLE
AS
RETURN (SELECT ID,NAMES,CITY,GENDER FROM EMPLOYEE WHERE GENDER = @GENDER)

SELECT * FROM FN_GETEMPGENDER1('MALE');

SELECT * FROM FN_GETEMPGENDER1('FEMALE');

--EXISTS OPERATOR.

SELECT * FROM EMPLOYEE2;

SELECT * FROM EMPLOYEE2 WHERE EXISTS(SELECT 1); --IT WILL RETURN SAME EMPLOYEE2 TABLE BECAUSE EXISTS RESULT IS TRUE,BECAUSE 1 ROW IS RETURNING.

SELECT * FROM EMPLOYEE2 WHERE EXISTS(SELECT 0);--IT WILL RETURN SAME EMPLOYEE2 TABLE BECAUSE EXISTS RESULT IS TRUE,BECAUSE 1 ROW IS RETURNING.

SELECT * FROM EMPLOYEE2 WHERE EXISTS(SELECT NULL);--IT WILL RETURN SAME EMPLOYEE2 TABLE BECAUSE EXISTS RESULT IS TRUE,BECAUSE 1 ROW IS RETURNING.

--EXISTS WILL RETURN FALSE WHEN NO ROW WILL RETURN.

SELECT * FROM EMPLOYEE2 WHERE EXISTS(SELECT EMPLOYEEID FROM EMPLOYEE2 WHERE SALARY > 60000);

SELECT * FROM EMPLOYEE2 WHERE EXISTS(SELECT EMPLOYEEID FROM EMPLOYEE2 WHERE SALARY > 70000);

--BOTH ABOVE WRITTEN QUERY RETURN SAME TABLE AS EMPLOYEE2 TABLE, BECAUSE EXISTS OPERATOR CHECKS THAT ANY ROW IS RETURNING OR NOT FROM SUBQUERY.

--IF 0 ROW IS RETURNING THEN ONLY RESULT WILL BE FALSE AND NO ROW WILL RETURN. 

SELECT * FROM EMPLOYEE2 WHERE EXISTS(SELECT EMPLOYEEID FROM EMPLOYEE2 WHERE SALARY > 90000); /* IT WILL NOT RETURN ANY ROW BECAUSE THERE 
                                                                                                IS NO SALARY WHICH IS GREATER THAN OR EQUAL TO 
																								90000,SO THE VALUE OF EXISTS WILL BE FALSE*/
																						
--EXISTS IN IF CONDITION.

IF EXISTS(SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 2)
BEGIN
   SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 11;
END
ELSE
BEGIN
   SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 8;
END

IF EXISTS(SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 5)
BEGIN
   SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 11;
END
ELSE
BEGIN
   SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 8;
END

--NOT EXISTS

IF NOT EXISTS(SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 2)
BEGIN
   SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 11;
END
ELSE
BEGIN
   SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 8;
END

IF NOT EXISTS(SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 6)
BEGIN
   SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 11;
END
ELSE
BEGIN
   SELECT * FROM EMPLOYEE2 WHERE EMPLOYEEID = 8;
END

--EXISTS operator with Correlated Subquery: 

SELECT * FROM EMPLOYEE2 AS EMP WHERE EXISTS(SELECT * FROM EMPLOYEE2 WHERE EMP.SALARY > 60000); --WE USE TABLE ALIAS NAME IN SUBQUERY COLUMN NAME.
















